// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Jest = require("@glennsl/bs-jest/lib/js/src/jest.bs.js");
var List = require("bs-platform/lib/js/list.js");
var Task = require("../src/Task.bs.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");

function timeout(value) {
  return /* Task */{
          _0: (function (param, res) {
              var timer = setTimeout((function (param) {
                      return Curry._1(res, value);
                    }), value);
              return {
                      TAG: /* Cancel */0,
                      _0: (function (param) {
                          clearTimeout(timer);
                          
                        })
                    };
            })
        };
}

function notTimeout(value) {
  return /* Task */{
          _0: (function (param, res) {
              Curry._1(res, value);
              return /* NoCancel */0;
            })
        };
}

var p = Task.Operators.$great$great$pipe(Task.parallel(Pervasives.$at(List.map(timeout, {
                  hd: 1,
                  tl: {
                    hd: 2,
                    tl: {
                      hd: 3,
                      tl: {
                        hd: 4,
                        tl: {
                          hd: 5,
                          tl: {
                            hd: 6,
                            tl: {
                              hd: 7,
                              tl: {
                                hd: 8,
                                tl: {
                                  hd: 9,
                                  tl: /* [] */0
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }), $$Array.to_list($$Array.map(notTimeout, $$Array.mapi((function (index, param) {
                            return index + 10 | 0;
                          }), Caml_array.caml_make_vect(10000, 1)))))), (function (param) {
        return List.fold_left((function (a, b) {
                      return a + b | 0;
                    }), 0, param);
      }));

function makeTask(i) {
  if (i >= 100000) {
    return Task.pure({
                TAG: /* Done */1,
                _0: i + 1 | 0
              });
  } else if (i < 0) {
    return Task.reject("i must be positive");
  } else {
    return Task.pure({
                TAG: /* Next */0,
                _0: i + 1 | 0
              });
  }
}

var t = Task.Operators.$great$great$great(Task.Operators.$great$great$eq$bang(Task.Operators.$great$great$eq(Task.Operators.$great$great$pipe$bang(Task.Operators.$great$great$eq(Task.Operators.$great$great$pipe(Task.Operators.$great$great$eq(p, (function (param) {
                                return Task.chainRec(makeTask, param);
                              })), (function (m) {
                            return m + 10 | 0;
                          })), (function (m) {
                        return Task.pure(m + 100 | 0);
                      })), (function (param) {
                    return 100;
                  })), Task.reject), (function (m) {
            return Task.pure(m + 100 | 0);
          })), (function (v) {
        console.log(v._0);
        
      }));

Jest.describe("Testing Task", (function (param) {
        Jest.testAsync("basic run", undefined, (function (cb) {
                var simpleTask = /* Task */{
                  _0: (function (param, res) {
                      Curry._1(res, 10);
                      return /* NoCancel */0;
                    })
                };
                Task.run(simpleTask, (function (status) {
                        return Curry._1(cb, Jest.Expect.toEqual({
                                        TAG: /* Success */1,
                                        _0: 10
                                      }, Jest.Expect.expect(status)));
                      }));
                
              }));
        return Jest.testAsync("Cancelation Test", undefined, (function (cb) {
                      var cancel = Task.run(timeout(100), (function (param) {
                              if (param.TAG === /* Rejection */0) {
                                return Curry._1(cb, Jest.fail("should not reject"));
                              } else {
                                return Curry._1(cb, Jest.fail("should not run"));
                              }
                            }));
                      Curry._1(cancel, undefined);
                      setTimeout((function (param) {
                              return Curry._1(cb, Jest.pass);
                            }), 110);
                      
                    }));
      }));

exports.timeout = timeout;
exports.notTimeout = notTimeout;
exports.p = p;
exports.makeTask = makeTask;
exports.t = t;
/* p Not a pure module */
